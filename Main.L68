00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 11/23/2019 6:18:11 PM

00000000                             1  *--------------------------------------------------------------------------
00000000                             2  * Title      : Disassembler Skeleton 
00000000                             3  * Written by : You, and you should change all default comments
00000000                             4  * Date       :
00000000                             5  * 
00000000                             6  * Description: This code contains a method for you to use
00000000                             7  * with your Disassembler project IO, and a short demo of 
00000000                             8  * how to call this method in the body of the "START" code.
00000000                             9  * 
00000000                            10  * Hints and Tips:
00000000                            11  *   -Follow the code commenting convention here for file & method headers
00000000                            12  *   -Don't rename this file name (Main.X68)
00000000                            13  *   -Don't reorg the start address ($1000)
00000000                            14  *   -Don't rename or edit the IO method I've provided you with here
00000000                            15  *   -Don't rename the config.cfg file or change the file format: 
00000000                            16  *    <Long_StartAddress>\CR\LF
00000000                            17  *    <Long_EndAddress>\CR\LF<EOF>
00000000                            18  *---------------------------------------------------------------------------
00001000                            19      ORG    $1000    *Don't change this; see hints and tips above
00001000                            20  *---------------------------------------------------------------------------
00001000                            21  
00001000                            22      ; Read in from config.cfg
00001000  43F9 00001534             23      LEA     inFile, A1       ;in file name
00001006  303C 0033                 24      MOVE    #51, D0          ;open in file
0000100A  4E4F                      25      TRAP    #15
0000100C                            26  
0000100C                            27      ;Setup for Read
0000100C  343C 0004                 28      MOVE    #WORD_LENGTH, D2        ;# bytes to read
00001010  303C 0035                 29      MOVE    #53,d0                  ;read from file
00001014                            30  
00001014                            31      ; Read & store begin address in BEGIN_ADDRESS
00001014  43F9 0000153F             32      LEA     BEGIN_ADDRESS, A1
0000101A  4E4F                      33      TRAP    #15
0000101C  4EB9 000014BC             34      JSR     AsciiToHex
00001022  3647                      35      MOVE    D7, A3
00001024                            36      
00001024                            37      ; Read & store end address in END_ADDRESS
00001024  43F9 00001543             38      LEA     END_ADDRESS, A1
0000102A  4E4F                      39      TRAP    #15
0000102C  4EB9 000014BC             40      JSR     AsciiToHex
00001032  3847                      41      MOVE    D7, A4
00001034                            42  
00001034                            43  MAIN_LOOP:
00001034                            44  
00001034                            45      ; read word into D6 from current address
00001034  3C14                      46      MOVE.W  (A4), D6
00001036                            47  
00001036                            48      ; Append String with address of this operation by loading address value into A2?
00001036  344C                      49      MOVE    A4, A2
00001038  4EB9 000013FE             50      JSR     AppendOutput
0000103E                            51  
0000103E                            52  
0000103E                            53      ; disassemble word in D6:
0000103E  4EB9 0000104E             54      JSR DisassembleOpcode
00001044                            55          ; read opcode
00001044                            56              ; branch to 13 different opcode bins
00001044                            57              ; determine instruction and add string to ouput buffer
00001044                            58          ; read addresses
00001044                            59              ; determine addressing scheme
00001044                            60              ; add addresses to output buffer
00001044                            61          ; postcondition: A1 points to the null terminated output buffer to write
00001044                            62          ; call TRAPTask13 to output (A1)
00001044                            63  
00001044                            64      ; Increment Address
00001044  584B                      65      ADDQ.W      #WORD_LENGTH,A3        * Increment pointer
00001046                            66  
00001046                            67      ; Compare current address to end address
00001046  B6CC                      68      CMP         A4,A3           ; Are we done yet?
00001048  6FEA                      69      BLE         MAIN_LOOP       ; Branch if less than or equal too MAIN_LOOP
0000104A                            70      
0000104A                            71      ; end (print SIMHALT?  close file?)
0000104A                            72  
0000104A  FFFF FFFF                 73      SIMHALT
0000104E                            74  
0000104E                            75  *********************************************************************************
0000104E                            76  * Method Name: DisassembleOpcode
0000104E                            77  * Description: This method will determine which opcode is in the current word, and
0000104E                            78  *   write its ASCII assembly code equivalent into (A1)
0000104E                            79  * Preconditions:  D6 contains word-length opcode
0000104E                            80  * Postconditions: (A1) points to ASCII assembly code ending in 0
0000104E                            81  *********************************************************************************
0000104E                            82  DisassembleOpcode:
0000104E                            83      INCLUDE 'Determine_Opcode.X68'
0000104E                            84  
0000104E                            85  Opcode:
0000104E  48E7 3000                 86      MOVEM.L D2-D3, -(SP)            ; MOVEM all registers used
00001052                            87      
00001052  3406                      88      MOVE.W D6,D2         ; copy current word (D6) into opcode mask register (D2)
00001054  C47C F000                 89      AND #MASK_OPCODE,D2   ; apply mask to first 4 bits
00001058                            90  
00001058  B47C 9000                 91      CMP.W #$9000,D2      ; compare with 1001
0000105C  6700 0200                 92      BEQ SUB              ; if equal jump to SUB
00001060                            93      
00001060  B47C 5000                 94      CMP.W #$5000,D2      ; compare with 1010
00001064  6700 0244                 95      BEQ SUBQ             ; if equal jump to SUBQ
00001068                            96      
00001068  B47C C000                 97      CMP.W #$C000,D2      ; compare with 1100
0000106C  6700 023C                 98      BEQ MULS             ; if equal jump to MULS
00001070                            99      
00001070  B47C 0000                100      CMP.W #$0000,D2      ; compare with 0000
00001074  6600 003A                101      BNE Skip_0000        ; if not equal then skip
00001078  3606                     102      MOVE.W D6,D3         ; move current word into working register (D3)
0000107A  C67C 0DC0                103      AND #MASK_1110876,D3    ; mask bits 11,10,8,7,6
0000107E  B67C 0880                104      CMP.W #$0880,D3      ; compare with 10010
00001082  6700 025E                105      BEQ BCLR_I             ; if equal jump to BCLR
00001086  3606                     106      MOVE.W D6,D3         ; reset current word in D3
00001088  C67C 0100                107      AND #MASK_8,D3       ; mask bit 8
0000108C  B67C 0100                108      CMP.W #$0100,D3      ; compare with 1
00001090  6700 0250                109      BEQ BCLR             ; if equal jump to BCLR
00001094  3606                     110      MOVE.W D6,D3         ; reset current word in D3
00001096  C67C 0800                111      AND #MASK_11,D3      ; mask bit 11
0000109A  B67C 0800                112      CMP.W #$0800,D3      ; compare with 1
0000109E  6700 0226                113      BEQ CMPI             ; if equal jump to CMPI
000010A2  3606                     114      MOVE.W D6,D3         ; reset current word in D3
000010A4  C67C 0D00                115      AND #MASK_11108,D3      ; mask bit 11, 10,8
000010A8  B67C 0000                116      CMP.W #$0000,D3      ; compare with 000
000010AC  6700 01FC                117      BEQ ORI              ; if equal jump to ORI
000010B0                           118  Skip_0000:
000010B0                           119      
000010B0  B47C D000                120      CMP.W #$D000,D2      ; compare with 1101
000010B4  6600 0014                121      BNE Skip_1101        ; if not equal then skip
000010B8  3606                     122      MOVE.W D6,D3         ; move current word into working register (D3)
000010BA  C67C 00C0                123      AND #MASK_76,D3       ; mask bits 7, 6
000010BE  B67C 00C0                124      CMP.W #$00C0,D3      ; compare with 11
000010C2  6700 021E                125      BEQ ADDA             ; if equal jump to ADDA
000010C6  6600 021A                126      BNE ADD              ; if not equal jump to ADD
000010CA                           127  Skip_1101:
000010CA                           128  
000010CA  B47C 8000                129      CMP.W #$8000,D2      ; compare with 1000
000010CE  6600 0014                130      BNE Skip_1000        ; if not equal then skip
000010D2  3606                     131      MOVE.W D6,D3         ; move current word into working register (D3)
000010D4  C67C 00C0                132      AND #MASK_76,D3       ; mask bits 7, 6
000010D8  B67C 00C0                133      CMP.W #$00C0,D3      ; compare with 11
000010DC  6700 0204                134      BEQ DIVS             ; if equal jump to DIVS
000010E0  6600 0200                135      BNE OR               ; if not equal jump to OR
000010E4                           136  Skip_1000:
000010E4                           137   
000010E4  B47C B000                138      CMP.W #$B000,D2      ; compare with 1011
000010E8  6600 0014                139      BNE Skip_1011        ; if not equal then skip
000010EC  3606                     140      MOVE.W D6,D3         ; move current word into working register (D3)
000010EE  C67C 0100                141      AND #MASK_8,D3        ; mask bit 8
000010F2  B67C 0000                142      CMP.W #$0000,D3      ; compare with 0
000010F6  6700 01EA                143      BEQ CMP              ; if equal jump to CMP
000010FA  6600 01E6                144      BNE EOR              ; if not equal jump to EOR
000010FE                           145  Skip_1011:
000010FE                           146  
000010FE  B47C 1000                147      CMP.W #$1000,D2      ; compare with 0001
00001102  6600 0014                148      BNE Skip_0001        ; if not equal then skip
00001106  3606                     149      MOVE.W D6,D3         ; move current word into working register (D3)
00001108  C67C 01C0                150      AND #MASK_876,D3      ; mask bits 8, 7, 6
0000110C  B67C 0040                151      CMP.W #$0040,D3      ; compare with 001
00001110  6700 01D0                152      BEQ MOVEA_B          ; if equal jump to MOVEA_B
00001114  6600 01CC                153      BNE MOVE_B           ; if not equal jump to MOVE_B
00001118                           154  Skip_0001:
00001118                           155  
00001118  B47C 3000                156      CMP.W #$3000,D2      ; compare with 0011
0000111C  6600 0014                157      BNE Skip_0011        ; if not equal then skip
00001120  3606                     158      MOVE.W D6,D3         ; move current word into working register (D3)
00001122  C67C 01C0                159      AND #MASK_876,D3      ; mask bits 8, 7, 6
00001126  B67C 0040                160      CMP.W #$0040,D3      ; compare with 001
0000112A  6700 01B6                161      BEQ MOVEA_W          ; if equal jump to MOVEA_W
0000112E  6600 01B2                162      BNE MOVE_W           ; if not equal jump to MOVE_W
00001132                           163  Skip_0011:
00001132                           164  
00001132  B47C 2000                165      CMP.W #$2000,D2      ; compare with 0010
00001136  6600 0014                166      BNE Skip_0010        ; if not equal then skip
0000113A  3606                     167      MOVE.W D6,D3         ; move current word into working register (D3)
0000113C  C67C 01C0                168      AND #MASK_876,D3      ; mask bits 8, 7, 6
00001140  B67C 0040                169      CMP.W #$0040,D3      ; compare with 001
00001144  6700 019C                170      BEQ MOVEA_L          ; if equal jump to MOVEA_L
00001148  6600 0198                171      BNE MOVE_L           ; if not equal jump to MOVE_L
0000114C                           172  Skip_0010:
0000114C                           173  
0000114C  B47C E000                174      CMP.W #$E000,D2      ; compare with 1110
00001150  6600 007C                175      BNE Skip_1110        ; if not equal then skip
00001154  3606                     176      MOVE.W D6,D3         ; move current word into working register (D3)
00001156  C67C 00C0                177      AND #MASK_76,D3      ; mask bits 7, 6
0000115A  B67C 00C0                178      CMP.W #$00C0,D3      ; compare with 11
Line 179 ERROR: Invalid syntax
0000115E                           179      BNE 0110_Branch      ; branch to second half of check if not equal
0000115E  3606                     180      MOVE.W D6,D3         ; reset the word value in D3
00001160  C67C 0700                181      AND #MASK_1098,D3       ; mask bits 10, 9, 8
00001164  B67C 0600                182      CMP.W #$0600,D3      ; compare with 110
00001168  6700 0178                183      BEQ ROL              ; if equal jump to ROL
0000116C  B67C 0700                184      CMP.W #$0700,D3      ; compare with 111
00001170  6700 0170                185      BEQ ROR              ; if equal jump to ROR
00001174  B67C 0300                186      CMP.W #$0300,D3      ; compare with 011
00001178  6700 0168                187      BEQ LSL              ; if equal jump to LSL
0000117C  B67C 0200                188      CMP.W #$0200,D3      ; compare with 010
00001180  6700 0160                189      BEQ LSR              ; if equal jump to LSR
00001184  B67C 0100                190      CMP.W #$0100,D3      ; compare with 001
00001188  6700 0158                191      BEQ ASL              ; if equal jump to ASL
0000118C  B67C 0000                192      CMP.W #$0000,D3      ; compare with 000
00001190  6700 0150                193      BEQ ASR              ; if equal jump to ASR
00001194  6000 0038                194      BRA Skip_1110        ; no valid opcodes found, skip ahead
Line 195 ERROR: Illegal symbol
00001198                           195  0110_Branch:
00001198  3606                     196      MOVE.W D6,D3         ; reset the word value in D3
0000119A  C67C 0118                197      AND #MASK_843,D3     ; mask bits 8, 4, 3
0000119E  B67C 0118                198      CMP.W #$0118,D3      ; compare with 111
000011A2  6700 013E                199      BEQ ROL_I              ; if equal jump to ROL
000011A6  B67C 0018                200      CMP.W #$0018,D3      ; compare with 011
000011AA  6700 0136                201      BEQ ROR_I              ; if equal jump to ROR
000011AE  B67C 0108                202      CMP.W #$0108,D3      ; compare with 101
000011B2  6700 012E                203      BEQ LSL_I              ; if equal jump to LSL
000011B6  B67C 0008                204      CMP.W #$0008,D3      ; compare with 001
000011BA  6700 0126                205      BEQ LSR_I              ; if equal jump to LSR
000011BE  B67C 0100                206      CMP.W #$0100,D3      ; compare with 100
000011C2  6700 011E                207      BEQ ASL_I              ; if equal jump to ASL
000011C6  B67C 0000                208      CMP.W #$0000,D3      ; compare with 000
000011CA  6700 0116                209      BEQ ASR_I              ; if equal jump to ASR
000011CE                           210  Skip_1110:
000011CE                           211  
000011CE  B47C 6000                212      CMP.W #$6000,D2      ; compare with 0110
000011D2  6600 0030                213      BNE Skip_0110        ; if not equal then skip
000011D6  3606                     214      MOVE.W D6,D3         ; move current word into working register (D3)
000011D8  C67C 0F00                215      AND #MASK_111098,D3   ; mask bits 11, 10, 9, 8
000011DC  B67C 0000                216      CMP.W #$0000,D3      ; compare with 0000
Line 217 ERROR: Undefined symbol
000011E0  6700 AB34                217      BEQ BRA              ; if equal jump to BRA
000011E4  B67C 0500                218      CMP.W #$0500,D3      ; compare with 0101
000011E8  6700 010E                219      BEQ BCS              ; if equal jump to BCS
000011EC  B67C 0C00                220      CMP.W #$0C00,D3      ; compare with 1100
000011F0  6700 011C                221      BEQ BGE              ; if equal jump to BGE
000011F4  B67C 0D00                222      CMP.W #$0D00,D3      ; compare with 1101
000011F8  6700 012A                223      BEQ BLT              ; if equal jump to BLT
000011FC  B67C 0800                224      CMP.W #$0800,D3      ; compare with 1000
00001200  6700 0138                225      BEQ BVC              ; if equal jump to BVC
00001204                           226  Skip_0110:
00001204                           227  
00001204  B47C 4000                228      CMP.W #$4000,D2      ; compare with 0100
00001208  6600 0038                229      BNE Skip_0100        ; if not equal then skip
0000120C  3606                     230      MOVE.W D6,D3         ; move current word into working register (D3)
0000120E  B67C 4E75                231      CMP.W #$4E75,D3      ; check against constant RTS code
00001212  6700 013C                232      BEQ RTS              ; if equal jump to RTS
00001216  C67C 0100                233      AND #MASK_8,D3        ; mask bit 8
0000121A  B67C 0100                234      CMP #$0100,D3        ; compare with 1
0000121E  6700 0140                235      BEQ LEA              ; if equal jump to LEA
00001222  3606                     236      MOVE.W D6,D3         ; refresh current word into D3
00001224  C67C 0800                237      AND #MASK_11,D3       ; mask bit 11
00001228  B67C 0000                238      CMP #$0000,D3        ; compare with 0
0000122C  6700 0132                239      BEQ NEG              ; if equal jump to NEG
00001230  3606                     240      MOVE.W D6,D3         ; refresh current word into D3
00001232  C67C 0200                241      AND #MASK_9,D3        ; mask bit 9
00001236  B67C 0000                242      CMP #$0000,D3        ; compare with 0
0000123A  6700 0140                243      BEQ MOVEM            ; if equal jump to MOVEM
0000123E  6600 013C                244      BNE JSR              ; if not equal jump to JSR  
00001242                           245  Skip_0100:
00001242                           246  
00001242  BC7C FFFF                247      CMP.W #$FFFF,D6      ; compare with FFFF
00001246  6700 014A                248      BEQ SIMHALT          ; if equal jump to SIMHALT
0000124A                           249      
0000124A  6000 0002                250      BRA DATA             ; if no opcodes found jump to DATA
0000124E                           251  
0000124E                           252  
0000124E                           253  
0000124E                           254  
0000124E                           255  
0000124E                           256  
0000124E                           257  
0000124E                           258  
0000124E                           259  -------------------- end include --------------------
0000124E                           260      INCLUDE 'Breakdown_Opcode.X68'
0000124E                           261  
0000124E                           262  DATA:
0000124E  45F9 000015DD            263      LEA STRINGDATA, A2
00001254  4EB9 000013FE            264      JSR AppendOutput            ; write the current string in A2 to the output string
0000125A                           265      ; print ASCII value of opcode in D6
0000125A  6000 0146                266      BRA Opcode_Finish
0000125E                           267  
0000125E                           268  SUB:
Line 269 ERROR: Undefined symbol
0000125E  45F9 004DBD16            269      LEA STRINGSUB, A2
00001264  4EB9 000013FE            270      JSR AppendOutput            ; write the current string in A2 to the output string
0000126A  4EB9 000013BE            271      JSR Size76
00001270  3606                     272      MOVE.W  D6,D3               ; move word value into D3
00001272  C67C 0100                273      AND #MASK_8, D3             ; mask bit 8
00001276  B67C 0000                274      CMP.W #$0000,D3             ; compare with 0
0000127A  6600 0018                275      BNE SUB_EA_DN_EA
0000127E                           276  SUB_DN_EA_DN:                   ; case  Dn + <ea> -> Dn
0000127E  4EB9 000013BC            277      JSR MXn
00001284  4EB9 000013EE            278      JSR Comma
0000128A  4EB9 000013C2            279      JSR Dn
00001290  6000 0110                280      BRA Opcode_Finish
00001294                           281  SUB_EA_DN_EA:                   ; case <ea> + Dn -> <ea>
00001294  4EB9 000013C2            282      JSR Dn
0000129A  4EB9 000013EE            283      JSR Comma
000012A0  4EB9 000013BC            284      JSR MXn
000012A6  6000 00FA                285      BRA Opcode_Finish
000012AA                           286  
000012AA                           287  SUBQ:
000012AA                           288  MULS:
000012AA                           289  ORI:
000012AA  45F9 0000160B            290      LEA STRINGORI, A2
000012B0  4EB9 000013FE            291      JSR AppendOutput            ; write the current string in A2 to the output string
000012B6  4EB9 000013BE            292      JSR Size76
000012BC  4EB9 000013BC            293      JSR MXn
000012C2                           294      ; if size == byte then fetch next byte
000012C2                           295      ; if size == word then fetch next word
000012C2                           296      ; if size == long then fetch next long
000012C2  6000 00DE                297      BRA Opcode_Finish
000012C6                           298  
000012C6                           299  CMPI:
000012C6  45F9 00001610            300      LEA STRINGCMPI, A2
000012CC  4EB9 000013FE            301      JSR AppendOutput            ; write the current string in A2 to the output string
000012D2  4EB9 000013BE            302      JSR Size76
000012D8  4EB9 000013BC            303      JSR MXn
000012DE                           304      ; if size == byte then fetch next byte
000012DE                           305      ; if size == word then fetch next word
000012DE                           306      ; if size == long then fetch next long
000012DE  6000 00C2                307      BRA Opcode_Finish
000012E2                           308  
000012E2                           309  BCLR:
000012E2                           310  BCLR_I:
000012E2                           311  ADDA:
000012E2                           312  ADD:
000012E2                           313  DIVS:
000012E2                           314  OR: 
000012E2                           315  CMP:
000012E2                           316  EOR:  
000012E2                           317  MOVEA_B:
000012E2                           318  MOVE_B:
000012E2                           319  MOVEA_W:
000012E2                           320  MOVE_W:
000012E2                           321  MOVEA_L:
000012E2                           322  MOVE_L:
000012E2                           323  ROL:
000012E2                           324  ROR:
000012E2                           325  LSL:
000012E2                           326  LSR:
000012E2                           327  ASL:
000012E2                           328  ASR:
000012E2                           329  ROL_I:
000012E2                           330  ROR_I:
000012E2                           331  LSL_I:
000012E2                           332  LSR_I:
000012E2                           333  ASL_I:
000012E2                           334  ASR_I:
000012E2                           335  BRA_I:
000012E2  45F9 000015F2            336      LEA STRINGBRA, A2
000012E8  4EB9 000013FE            337      JSR AppendOutput            ; write the current string in A2 to the output string
000012EE  4EB9 000013C0            338      JSR Displacement
000012F4  6000 00AC                339      BRA Opcode_Finish
000012F8                           340  
000012F8                           341  BCS:
000012F8  45F9 000015F7            342      LEA STRINGBCS, A2
000012FE  4EB9 000013FE            343      JSR AppendOutput            ; write the current string in A2 to the output string
00001304  4EB9 000013C0            344      JSR Displacement
0000130A  6000 0096                345      BRA Opcode_Finish
0000130E                           346  
0000130E                           347  BGE:
0000130E  45F9 000015FC            348      LEA STRINGBGE, A2
00001314  4EB9 000013FE            349      JSR AppendOutput            ; write the current string in A2 to the output string
0000131A  4EB9 000013C0            350      JSR Displacement
00001320  6000 0080                351      BRA Opcode_Finish
00001324                           352  
00001324                           353  BLT:
00001324  45F9 00001601            354      LEA STRINGBLT, A2
0000132A  4EB9 000013FE            355      JSR AppendOutput            ; write the current string in A2 to the output string
00001330  4EB9 000013C0            356      JSR Displacement
00001336  6000 006A                357      BRA Opcode_Finish
0000133A                           358  
0000133A                           359  BVC:
0000133A  45F9 00001606            360      LEA STRINGBVC, A2
00001340  4EB9 000013FE            361      JSR AppendOutput            ; write the current string in A2 to the output string
00001346  4EB9 000013C0            362      JSR Displacement
0000134C  6000 0054                363      BRA Opcode_Finish
00001350                           364  
00001350                           365  RTS:
00001350  45F9 000015E3            366      LEA STRINGRTS, A2
00001356  4EB9 000013FE            367      JSR AppendOutput            ; write the current string in A2 to the output string
0000135C  6000 0044                368      BRA Opcode_Finish
00001360                           369  
00001360                           370  LEA:
00001360                           371  NEG:
00001360  45F9 000015ED            372      LEA STRINGNEG, A2
00001366  4EB9 000013FE            373      JSR AppendOutput            ; write the current string in A2 to the output string
0000136C  4EB9 000013BE            374      JSR Size76
00001372  4EB9 000013BC            375      JSR MXn
00001378  6000 0028                376      BRA Opcode_Finish
0000137C                           377      
0000137C                           378  MOVEM:
0000137C                           379  JSR:
0000137C  45F9 000015E8            380      LEA STRINGJSR, A2
00001382  4EB9 000013FE            381      JSR AppendOutput            ; write the current string in A2 to the output string
00001388  4EB9 000013BC            382      JSR MXn
0000138E  6000 0012                383      BRA Opcode_Finish
00001392                           384  
00001392                           385  SIMHALT:
00001392  45F9 00001616            386      LEA STRINGSIMHALT, A2
00001398  4EB9 000013FE            387      JSR AppendOutput            ; write the current string in A2 to the output string
0000139E  6000 0002                388      BRA Opcode_Finish
000013A2                           389  
000013A2                           390  Opcode_Finish: 
000013A2  43F9 00001547            391      LEA OUTPUT, A1              ; Load Output into A1
000013A8  4EB9 00001426            392      JSR TrapTask13              ; Send it to the printer
000013AE  33FC 0000 00000000       393      MOVE #0, CURRENT_STR_LENGTH   ;Set current string length back to zero to be written over
000013B6  4CDF 000C                394      MOVEM.L (SP)+, D2-D3        ; return registers to their previous state
000013BA  4E75                     395      RTS                         ; return from function
000013BC                           396  
000013BC                           397  
000013BC                           398  
000013BC                           399  -------------------- end include --------------------
000013BC                           400      INCLUDE 'Addressing.X68'
000013BC                           401  
000013BC                           402  
000013BC                           403  MXn:
000013BC                           404      ; mask 543
000013BC                           405      ; check value against 8 possible addressing methods
000013BC                           406      ; mask 210
000013BC                           407      ; interpret
000013BC                           408      ; append ASCII to A1
000013BC  4E75                     409      RTS
000013BE                           410  
000013BE                           411  Size76:
000013BE                           412      ; mask 76
000013BE                           413      ; check value against 3 possible sizes
000013BE                           414      ; append ASCII to A1
000013BE  4E75                     415      RTS
000013C0                           416  
000013C0                           417  Displacement:
000013C0                           418      ; mask 76543210
000013C0                           419      ; check against 00000000
000013C0                           420      ; if 0 then get next word
000013C0                           421      ; append ASCII to A1
000013C0  4E75                     422      RTS
000013C2                           423  
000013C2                           424  
000013C2                           425  Dn:
000013C2  3606                     426      MOVE.W  D6,D3           ; move word into D3
Line 427 ERROR: Undefined symbol
000013C4  C679 004DBD16            427      AND.W   MASK_11109, D3  ; mask bits 11, 10, 9 
000013CA  EF5B                     428      ROL.W   #7,D3           ; rotate so bits are in least significant spot
000013CC  C6FC 0002                429      MULU.W  #2,D3           ; multiply by 2 so offset is measured in words not bytes
Line 430 ERROR: Invalid syntax
000013D0                           430      MOVE.W  (EA_StrArray_Dn,D3),A2   ; move string value from StrArray_Dn with offset D3 into A2
000013D0  4EB9 000013FE            431      JSR     AppendOutput    ; print string in A2
000013D6  4E75                     432      RTS
000013D8                           433  
000013D8                           434  An:
000013D8  3606                     435      MOVE.W  D6,D3           ; move word into D3
Line 436 ERROR: Undefined symbol
000013DA  C679 004DBD16            436      AND.W   MASK_11109, D3  ; mask bits 11, 10, 9 
000013E0  EF5B                     437      ROL.W   #7,D3           ; rotate so bits are in least significant spot
000013E2  C6FC 0002                438      MULU.W  #2,D3           ; multiply by 2 so offset is measured in words not bytes
Line 439 ERROR: Invalid syntax
000013E6                           439      MOVE.W  (EA_StrArray_An,D3),A2   ; move string value from StrArray_An with offset D3 into A2
000013E6  4EB9 000013FE            440      JSR     AppendOutput    ; print string in A2
000013EC  4E75                     441      RTS
000013EE                           442  
000013EE                           443  Comma:
000013EE  3479 000015DA            444      MOVE.W STRCOMMA, A2     ; move string comma into A2
000013F4  4EB9 000013FE            445      JSR     AppendOutput    ; print string in A2
000013FA  4E75                     446      RTS
000013FA  4E75                     447  -------------------- end include --------------------
000013FC  4E75                     448      RTS
000013FE                           449  
000013FE                           450  
000013FE                           451  *********************************************************************************
000013FE                           452  * Method Name:  AppendOutput
000013FE                           453  * Description:  This file will be included in Main.X68 disassembler program
000013FE                           454  *       When opcodes is being broken down we will be actively appending the
000013FE                           455  *       output string to prepare for TRAPTask13
000013FE                           456  *
000013FE                           457  * Preconditions: Appending String is in A2 and must end in null
000013FE                           458  *                string constants are in Gbl_CONST.X68
000013FE                           459  *
000013FE                           460  *********************************************************************************
000013FE                           461  AppendOutput:
000013FE                           462      INCLUDE 'AppendOutput.X68'
000013FE                           463  SaveItFam REG A1/D1
000013FE                           464  
000013FE                           465      ;Save context
000013FE  48E7 4040                466      MOVEM.L SaveItFam, -(SP)
00001402                           467  
00001402                           468      ;Load Current Output into A1
00001402  43F9 00001547            469      LEA OUTPUT, A1
00001408                           470  
00001408                           471      ;Counter D1, Must be set to -1 to deal with incrementing before moving bytes!
00001408  323C FFFF                472      MOVE    #-1, D1
0000140C                           473  
0000140C                           474      ;Get to the current position of the string 
0000140C  D2F9 00000000            475      ADD     CURRENT_STR_LENGTH, A1
00001412                           476  
00001412                           477      ;Now that we are in position, start appending the string in A2
00001412                           478  APPENDLOOP:
00001412  5241                     479      ADDI    #1, D1                      ;Increment Current Length by 1
00001414  12DA                     480      MOVE.B  (A2)+, (A1)+                ;Move the Byte in A2 to our Output
00001416  66FA                     481      BNE     APPENDLOOP                  ; If zero has not been reached, Loop Back
00001418                           482  
00001418                           483      ;Update Current String Length with our counter
00001418  D379 00000000            484      ADD     D1, CURRENT_STR_LENGTH
0000141E                           485  
0000141E                           486      ; restore context
0000141E  4CDF 0202                487      MOVEM.L (SP)+, SaveItFam
00001422                           488      
00001422  4E75                     489      RTS
00001424                           490  
00001424                           491  -------------------- end include --------------------
00001424  4E75                     492      RTS
00001426                           493  
00001426                           494  
00001426                           495  *********************************************************************************
00001426                           496  * Method Name: TrapTask13
00001426                           497  * Description: Creates a file if none exists, and appends bytes to that file
00001426                           498  *   while also echoing the written bytes to the screen.  You shouldn't need to
00001426                           499  *   change this code.
00001426                           500  *
00001426                           501  * Calling Convention: Callee-Saved 
00001426                           502  *
00001426                           503  * Preconditions & Method Input:
00001426                           504  *   A1 points to the null-terminated buffer to write (newline will be added for you)
00001426                           505  *
00001426                           506  * Postconditions & Output:
00001426                           507  *   ALL files that were previously open will be CLOSED (FileIDs will be invalid)
00001426                           508  *   See 'Output.txt' in directory for the results, also piped to the console
00001426                           509  *
00001426                           510  *
00001426                           511  *  A2 holds a pointer to null terminated string to write (input)
00001426                           512  *  A3 points to the null-terminated file name
00001426                           513  *  D3 holds the number of bytes already in the file to write
00001426                           514  *
00001426                           515  *  D5 holds number of bytes to write
00001426                           516  ********************************************************************************
00001426                           517  toSave REG D0-D5/A2-A3
00001426                           518  TrapTask13:
00001426                           519      *******************************************************************
00001426                           520      * Method initialization, regsiter spilling, parameter saving, etc.
00001426                           521      *******************************************************************
00001426  48E7 FC30                522      MOVEM.L toSave, -(SP)   ;  Callee-Saved, so save and restore     
0000142A                           523        
0000142A  2449                     524      MOVEA.L A1, A2 ; save this buffer to write
0000142C  47F9 00001520            525      LEA outFilename, A3  ; save this for later, too
00001432                           526        
00001432  303C 0032                527      MOVE #50,d0   
00001436  4E4F                     528      TRAP #15 ; close all files, suggested to begin any IO 
00001438                           529      *******************************************************************
00001438                           530      * End Method Init
00001438                           531      *******************************************************************
00001438                           532  
00001438                           533      ******************************************************************************************
00001438                           534      * Calculate the number of bytes to write by searching for the null in the target buffer A0
00001438                           535      ******************************************************************************************
00001438  4285                     536      CLR.L D5 *D5 is now the number of bytes to write
0000143A                           537  nullLoop:
0000143A  1019                     538      MOVE.B (A1)+, D0
0000143C  0C00 0000                539      CMPI.B #0,D0  * compare to null
00001440  6700 0006                540      BEQ findNullLoopDone
00001444  5245                     541      ADDI.W #1, D5
00001446  60F2                     542      BRA nullLoop
00001448                           543      
00001448                           544  findNullLoopDone:
00001448  224B                     545      MOVEA.L A3, A1 * reset A1 so it points to the file to write to (to open, next)
0000144A                           546      
0000144A                           547      ;check if file exists, and open with task 51 if so, otherwise 52
0000144A                           548      ;(precondition here is A1 points to the null-terminated filename )
0000144A  103C 0033                549      MOVE.B #51, D0      ;open file (task 51 is existing, 52 is new)
0000144E  4E4F                     550      TRAP #15
00001450                           551        
00001450                           552      if.w D0 <NE> #0 then.s         ; if file error (404, not found)
00001456  103C 0034                553          MOVE.B #52, D0             ; open new file (52 is new)
0000145A  4E4F                     554          TRAP #15
0000145C                           555      endi
0000145C                           556      
0000145C                           557      ********************************************************************************************************* 
0000145C                           558      * Seek to END of FILE by counting the number of bytes, closing, reopening, then seeking.
0000145C                           559      *    (first, count number of bytes already in the file to obtain seek position)
0000145C                           560      *********************************************************************************************************
0000145C  4283                     561      Clr.L D3   ;TODO: reg save, D3 is now our count of bytes read
0000145E  7401                     562      MOVE.L #1, D2 ; read one byte at a time
00001460  43F9 0000152B            563      LEA byteRead, A1
00001466                           564      
00001466                           565  countLoop:
00001466  103C 0035                566      MOVE.B #53, D0 ; try to read one byte (TODO: MOVE out of loop)
0000146A  4E4F                     567      TRAP #15
0000146C                           568      
0000146C  0C40 0001                569      CMPI.W #1,D0  ;1 == EOF
00001470  6700 0006                570      BEQ countDone
00001474  5243                     571      ADDI #1, D3
00001476  60EE                     572      BRA countLoop
00001478                           573      
00001478                           574  countDone:    
00001478                           575      * close this file
00001478  303C 0038                576       MOVE #56,d0  
0000147C  4E4F                     577       TRAP #15 
0000147E                           578       
0000147E                           579       * reopen the target file
0000147E  224B                     580       MOVE.L A3,A1
00001480  303C 0033                581       MOVE #51, D0
00001484  4E4F                     582       TRAP #15
00001486                           583       
00001486                           584      * seek to right position, then continue with writing
00001486  2403                     585      MOVE.L D3, D2 ; MOVE the number of bytes found in the file to D2
00001488  303C 0037                586      MOVE #55, D0  ; position file task
0000148C  4E4F                     587      TRAP #15
0000148E                           588  
0000148E                           589      ******************************************************************************
0000148E                           590      * Actually write the buffer to the file, after caculating the number of bytes 
0000148E                           591      *  to write and after seeking to the right location in the file for append
0000148E                           592      ******************************************************************************
0000148E                           593  
0000148E  2405                     594      MOVE.L D5, D2 ; restore this for the actually writing the buffer 
00001490                           595      ; assumes A0 hasnt changed since handed to this method      
00001490  224A                     596      MOVEA.L A2, A1 ; load the address of the buffer we want to write to disk
00001492                           597      ; assumes file ID is still stored in D1.L  
00001492  103C 0036                598      MOVE.B #54, D0 ; subtask 54 is write to open file (append, or?), assumes D2 holds # of bytes
00001496  4E4F                     599      TRAP #15
00001498                           600  
00001498                           601      ; add a newline to the file output
00001498  43F9 00001504            602      LEA NEWLINE, A1
0000149E  103C 0036                603      MOVE.B #54, D0 
000014A2  143C 0002                604      MOVE.B #2,D2  ; kills # of bytes to write from input param
000014A6  4E4F                     605      TRAP #15
000014A8                           606      
000014A8                           607      ; finally, close only this file
000014A8  103C 0038                608      MOVE.B #56, D0 ; close file task
000014AC  4E4F                     609      TRAP #15
000014AE                           610    
000014AE                           611      ; report to screen
000014AE  224A                     612      MOVEA.L A2, A1 ; load the address of the buffer we want to write to disk & screen
000014B0  103C 000D                613      MOVE.B #13, D0
000014B4  4E4F                     614      TRAP #15
000014B6                           615        
000014B6                           616      ; restore context
000014B6  4CDF 0C3F                617      MOVEM.L (SP)+, toSave
000014BA                           618      
000014BA  4E75                     619      RTS
000014BC                           620      
000014BC                           621      
000014BC                           622  *----------------------------------------------------------------------------------
000014BC                           623  * Method Name: AsciiToHex
000014BC                           624  * Written by : Berger, Modified by Nash
000014BC                           625  * Date       : 3/1/2019
000014BC                           626  * Description: Converts chars '0'-'9' and 'a'-'f' to 0-9,a-F
000014BC                           627  *              Transforms/unpacks 8 chars (8b each) pointed to by A1 into 
000014BC                           628  *              its (4b each) equivalent hex value 
000014BC                           629  *  
000014BC                           630  *  Preconditions & Input
000014BC                           631  *       A1 (input) points to a memory buffer holding 8 ascii chars (not null-terminated) 
000014BC                           632  *       This function calls another function (strip_ascii)
000014BC                           633  *
000014BC                           634  *  Postconditions & Output
000014BC                           635  *       D7 (output) holds the converted value 
000014BC                           636  *       Caller-Saved : D0 is temp, D6 is a loop var
000014BC                           637  *----------------------------------------------------------------------------------
000014BC                           638  AsciiToHexRegList REG D0,D6
000014BC                           639  AsciiToHex     
000014BC  48E7 8000                640      MOVEM.L asciiToHexRegList, -(SP)  *save context
000014C0  4287                     641      CLR.L D7 * cLEAr our return value
000014C2  7C08                     642      MOVE.L #8, D6 ; and set up our loop counter
000014C4                           643  
000014C4                           644  chrLoop
000014C4  1019                     645      MOVE.B (A1)+,D0 * Get the first byte
000014C6  4EB9 000014DE            646      jsr strip_ascii * Get rid of the ascii code    
000014CC  8E40                     647      OR.W D0,D7 * Load the bits into D7
000014CE                           648      
000014CE  5306                     649      subI.B #1,D6  *decrement our loop variable
000014D0  6700 0006                650      BEQ chrDone   *skip shifting if we are done
000014D4                           651      
000014D4  E987                     652      ASL.L #4,D7 * shift left 4 bits to prepare for next byte
000014D6  60EC                     653      BRA chrLoop
000014D8                           654  
000014D8                           655  chrDone
000014D8  4CDF 0001                656      MOVEM.L (SP)+,asciiToHexRegList 
000014DC  4E75                     657      RTS
000014DE                           658  
000014DE                           659  
000014DE                           660  **********************************************************************
000014DE                           661  * SUBROUTINE: strip_ascii
000014DE                           662  * reMOVE the ascii code from the digits 0-9,a-f, or A-F
000014DE                           663  * Input Parameters: <D0> = ascii code
000014DE                           664  *
000014DE                           665  * Return parameters: D0.B = number 0...F, returned as 00...0F
000014DE                           666  * Registers used internally: D0
000014DE                           667  * Assumptions: D0 contains $30-$39, $41-$46 or $61-66
000014DE                           668  *
000014DE                           669  ***********************************************************************
000014DE                           670  strip_ascii
000014DE  B03C 0039                671        CMP.B #$39,D0 * Is it in range of 0-9?
000014E2  6F00 001A                672        BLE sub30 * Its a number
000014E6  B03C 0046                673        CMP.B #$46,D0 * Is is A...F?
000014EA  6F00 000A                674        BLE sub37 * Its A...F
000014EE  0400 0057                675        SUB.B #$57,D0 * Its a...f
000014F2  6000 000E                676        BRA ret_sa * Go back
000014F6  0400 0037                677  sub37 SUB.B #$37,D0 * Strip 37
000014FA  6000 0006                678        BRA ret_sa * Go back
000014FE  0400 0030                679  sub30 SUB.B #$30,D0 * Strip 30
00001502  4E75                     680  ret_sa RTS * Go back
00001504                           681  
00001504                           682      
00001504                           683  * Required variables and constants go here for your Disassembler
00001504  =0000000D                684  CR                  EQU $0D
00001504  =0000000A                685  LF                  EQU $0A
00001504= 0D 0A 00                 686  NEWLINE             DC.B CR,LF,0  
00001507= 4D 4F 56 45 2E 4C ...    687  MSG1                DC.B 'MOVE.L D4,D5',0
00001514= 41 44 44 2E 42 20 ...    688  MSG2                DC.B 'ADD.B D0,D1',0
00001520= 4F 75 74 70 75 74 ...    689  outFilename         DC.B 'Output.txt',0
0000152B                           690  byteRead            DS.B 1
0000152C= 31 41 30 30 31 41 ...    691  ascii_val           DC.B $31,$41,$30,$30,$31,$41,$30,$30 * Test value $1A001A00
00001534                           692      INCLUDE 'Gbl_CONST.X68'
00001534                           693  
00001534= 43 6F 6E 66 69 67 ...    694  inFile          DC.B 'Config.cfg',0
0000153F                           695  BEGIN_ADDRESS   DS.B 4
00001543                           696  END_ADDRESS     DS.B 4
00001547                           697  
00001547  =00000000                698  EMPTY_ADDRESS   EQU    $00000000
00001547                           699  
00001547  =00000002                700  BYTE_LENGTH     EQU     2
00001547  =00000004                701  WORD_LENGTH     EQU     4
00001547  =00000008                702  LONG_LENGTH     EQU     8 
00001547                           703  
00001547  =00000009                704  TAB     EQU     $09
00001547                           705  
00001547  =00000400                706  FILE_DEFAULT_READ_BYTES  EQU 1024
00001547                           707  
00001547                           708  
00001547  =00000000                709  CURRENT_STR_LENGTH  SET     0
00001547  =00000028                710  OUTPUT_LENGTH       EQU     40
00001547                           711  OUTPUT              DS.B    OUTPUT_LENGTH
0000156F                           712  
00001570= 5375 6363 6573 7...      713  ERROR_CODE_FILE_0  DC.W    'Success',0
0000157A= 454F 4620 456E 6...      714  ERROR_CODE_FILE_1  DC.W    'EOF Encountered',0
0000158C= 4572 726F 7200 0000      715  ERROR_CODE_FILE_2  DC.W    'Error',0
00001594= 4669 6C65 2069 7...      716  ERROR_CODE_FILE_3  DC.W    'File is Read only',0
000015A8                           717  
000015A8= 5375 6363 6573 7...      718  FILE_ERROR_ARRAY   DC.W    'Success','EOF Encountered','Error','File is Read only',0
000015DA                           719  
000015DA= 2C 20 00                 720  STRCOMMA    DC.B    ', ',0    
000015DD                           721  
000015DD= 09 44 41 54 41 00        722  STRINGDATA  DC.B    TAB,'DATA',0
000015E3= 09 52 54 53 00           723  STRINGRTS  DC.B    TAB,'RTS',0
000015E8= 09 4A 53 52 00           724  STRINGJSR  DC.B    TAB,'JSR',0
000015ED= 09 4E 45 47 00           725  STRINGNEG  DC.B    TAB,'NEG',0
000015F2= 09 42 52 41 00           726  STRINGBRA  DC.B    TAB,'BRA',0
000015F7= 09 42 43 53 00           727  STRINGBCS  DC.B    TAB,'BCS',0
000015FC= 09 42 47 45 00           728  STRINGBGE  DC.B    TAB,'BGE',0
00001601= 09 42 4C 54 00           729  STRINGBLT  DC.B    TAB,'BLT',0
00001606= 09 42 56 43 00           730  STRINGBVC  DC.B    TAB,'BVC',0
0000160B= 09 4F 52 49 00           731  STRINGORI  DC.B    TAB,'ORI',0
00001610= 09 43 4D 50 49 00        732  STRINGCMPI  DC.B    TAB,'CMPI',0
00001616= 09 53 49 4D 48 41 ...    733  STRINGSIMHALT DC.B   TAB,'SIMHALT',0
0000161F                           734  
0000161F                           735  
0000161F                           736  
0000161F  =0000F000                737  MASK_OPCODE     EQU     $F000
0000161F  =00000F00                738  MASK_111098     EQU     $0F00
0000161F  =00000DC0                739  MASK_1110876    EQU     $0DC0
0000161F  =00000C00                740  MASK_1110       EQU     $0C00
0000161F  =00000D00                741  MASK_11108      EQU     $0D00
0000161F  =00000800                742  MASK_11         EQU     $0800
0000161F  =00000700                743  MASK_1098       EQU     $0700
0000161F  =00000200                744  MASK_9          EQU     $0200
0000161F  =000001C0                745  MASK_876        EQU     $01C0
0000161F  =00000118                746  MASK_843        EQU     $0118
0000161F  =00000100                747  MASK_8          EQU     $0100
0000161F  =000000C0                748  MASK_76         EQU     $00C0
0000161F  =00000018                749  MASK_43         EQU     $0018
0000161F                           750  
0000161F                           751     
0000161F                           752     
0000161F                           753     ; mask 4,3 
0000161F                           754     ; compare 01 
0000161F                           755     ; BEQ LSX subroutine 
0000161F                           756     ; BLT ASX subroutine 
0000161F                           757     ; BRA ROX subroutine 
0000161F                           758     ;RTS 
0000161F                           759     
0000161F                           760      ; LSX subroutine
0000161F                           761      ;mask 8
0000161F                           762      ;if equals 0 lsr
0000161F                           763      ; equals lsl 
0000161F                           764      ;RTS
0000161F                           765      
0000161F                           766      ; ROX subroutine
0000161F                           767      ;mask 8
0000161F                           768      ;if equals 0 rsr
0000161F                           769      ; equals rsl 
0000161F                           770      ;RTS
0000161F                           771      
0000161F                           772      ; ASX subroutine
0000161F                           773      ;mask 8
0000161F                           774      ;if equals 0 asr
0000161F                           775      ; equals asl 
0000161F                           776      ;RTS
0000161F                           777      
0000161F                           778  
0000161F                           779  
0000161F                           780  
0000161F                           781  
0000161F                           782  -------------------- end include --------------------
0000161F                           783  
0000161F                           784     END    $1000        ; last line of source

8 errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 12E2
ADDA                12E2
AN                  13D8
APPENDLOOP          1412
APPENDOUTPUT        13FE
ASCIITOHEX          14BC
ASCIITOHEXREGLIST   1
ASCII_VAL           152C
ASL                 12E2
ASL_I               12E2
ASR                 12E2
ASR_I               12E2
BCLR                12E2
BCLR_I              12E2
BCS                 12F8
BEGIN_ADDRESS       153F
BGE                 130E
BLT                 1324
BRA_I               12E2
BVC                 133A
BYTEREAD            152B
BYTE_LENGTH         2
CHRDONE             14D8
CHRLOOP             14C4
CMP                 12E2
CMPI                12C6
COMMA               13EE
COUNTDONE           1478
COUNTLOOP           1466
CR                  D
CURRENT_STR_LENGTH  0
DATA                124E
DISASSEMBLEOPCODE   104E
DISPLACEMENT        13C0
DIVS                12E2
DN                  13C2
EMPTY_ADDRESS       0
END_ADDRESS         1543
EOR                 12E2
ERROR_CODE_FILE_0   1570
ERROR_CODE_FILE_1   157A
ERROR_CODE_FILE_2   158C
ERROR_CODE_FILE_3   1594
FILE_DEFAULT_READ_BYTES  400
FILE_ERROR_ARRAY    15A8
FINDNULLLOOPDONE    1448
INFILE              1534
JSR                 137C
LEA                 1360
LF                  A
LONG_LENGTH         8
LSL                 12E2
LSL_I               12E2
LSR                 12E2
LSR_I               12E2
MAIN_LOOP           1034
MASK_1098           700
MASK_11             800
MASK_1110           C00
MASK_11108          D00
MASK_1110876        DC0
MASK_111098         F00
MASK_43             18
MASK_76             C0
MASK_8              100
MASK_843            118
MASK_876            1C0
MASK_9              200
MASK_OPCODE         F000
MOVEA_B             12E2
MOVEA_L             12E2
MOVEA_W             12E2
MOVEM               137C
MOVE_B              12E2
MOVE_L              12E2
MOVE_W              12E2
MSG1                1507
MSG2                1514
MULS                12AA
MXN                 13BC
NEG                 1360
NEWLINE             1504
NULLLOOP            143A
OPCODE              104E
OPCODE_FINISH       13A2
OR                  12E2
ORI                 12AA
OUTFILENAME         1520
OUTPUT              1547
OUTPUT_LENGTH       28
RET_SA              1502
ROL                 12E2
ROL_I               12E2
ROR                 12E2
ROR_I               12E2
RTS                 1350
SAVEITFAM           202
SIMHALT             1392
SIZE76              13BE
SKIP_0000           10B0
SKIP_0001           1118
SKIP_0010           114C
SKIP_0011           1132
SKIP_0100           1242
SKIP_0110           1204
SKIP_1000           10E4
SKIP_1011           10FE
SKIP_1101           10CA
SKIP_1110           11CE
STRCOMMA            15DA
STRINGBCS           15F7
STRINGBGE           15FC
STRINGBLT           1601
STRINGBRA           15F2
STRINGBVC           1606
STRINGCMPI          1610
STRINGDATA          15DD
STRINGJSR           15E8
STRINGNEG           15ED
STRINGORI           160B
STRINGRTS           15E3
STRINGSIMHALT       1616
STRIP_ASCII         14DE
SUB                 125E
SUB30               14FE
SUB37               14F6
SUBQ                12AA
SUB_DN_EA_DN        127E
SUB_EA_DN_EA        1294
TAB                 9
TOSAVE              C3F
TRAPTASK13          1426
WORD_LENGTH         4
0110_BRANCH         32BD3E4
_00000000           145C
